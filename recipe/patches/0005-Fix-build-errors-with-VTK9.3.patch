From f355f8066159fba2665a3937d48b53b6da169a33 Mon Sep 17 00:00:00 2001
From: Tom Sobczynski <toms@gentuity.com>
Date: Thu, 11 Apr 2024 17:08:48 -0400
Subject: [PATCH] Updates for compatibility with ITK 5.4 and VTK 9.3 plus some
 extra consideration for CMake 3.29

---
 CMakeLists.txt                                | 10 ++-
 .../vtkvmtkSimplifyVoronoiDiagram.cxx         |  6 +-
 .../Contrib/vtkvmtkCellDimensionFilter.cxx    | 11 ++-
 ...cDiffusionVesselEnhancementImageFilter.txx | 31 +++++++
 ...stMarchingDirectionalFreezeImageFilter.txx |  8 ++
 ...kFastMarchingUpwindGradientImageFilter.txx |  8 ++
 ...oothed3DToVesselnessMeasureImageFilter.txx |  5 ++
 ...stMarchingDirectionalFreezeImageFilter.cxx |  8 ++
 ...kFastMarchingUpwindGradientImageFilter.cxx |  8 ++
 .../Segmentation/vtkvmtkMedialCurveFilter.cxx |  9 ++-
 vtkVmtk/Utilities/Doxygen/CMakeLists.txt      |  2 +-
 .../vtkvmtkITKArchetypeImageSeriesReader.cxx  | 80 +++++++++++++++++++
 .../vtkvmtkITKArchetypeImageSeriesReader.h    | 18 +++++
 13 files changed, 193 insertions(+), 11 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4043110..0d46a7c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 3.3)
+cmake_minimum_required(VERSION 3.12...3.29.1)
 
 project(VMTK)
 
@@ -27,7 +27,7 @@ if(VMTK_WITH_LIBRARY_VERSION)
      )
 endif()
 
-find_package( PythonInterp )
+find_package( Python3 COMPONENTS Interpreter )
 if (NOT VMTK_PYTHON_VERSION)
   set(VMTK_PYTHON_VERSION "python${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}" CACHE STRING "" FORCE)
 endif ()
@@ -309,11 +309,17 @@ if(VMTK_SCRIPTS_ENABLED)
     ${VMTK_BINARY_DIR}/VMTKConfig.cmake
   @ONLY IMMEDIATE
   )
+  install(FILES ${VMTK_BINARY_DIR}/VMTKConfig.cmake
+    TYPE LIB
+  )
 
   configure_file(
     ${VMTK_SOURCE_DIR}/CMake/VMTKUse.cmake.in
     ${VMTK_BINARY_DIR}/VMTKUse.cmake
   @ONLY IMMEDIATE
   )
+  install(FILES ${VMTK_BINARY_DIR}/VMTKUse.cmake
+    TYPE LIB
+  )
 
 endif()
diff --git a/vtkVmtk/ComputationalGeometry/vtkvmtkSimplifyVoronoiDiagram.cxx b/vtkVmtk/ComputationalGeometry/vtkvmtkSimplifyVoronoiDiagram.cxx
index 3ac28f0..75b0218 100644
--- a/vtkVmtk/ComputationalGeometry/vtkvmtkSimplifyVoronoiDiagram.cxx
+++ b/vtkVmtk/ComputationalGeometry/vtkvmtkSimplifyVoronoiDiagram.cxx
@@ -195,8 +195,8 @@ int vtkvmtkSimplifyVoronoiDiagram::RequestData(
   //   return 0;
   //   }
   poly->SetPolys(currentPolys);
-  
-#if (VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 0 && VTK_BUILD_VERSION >= 20221108)
+
+#if ((VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 0 && VTK_BUILD_VERSION >= 20221108) || (VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 2 && VTK_BUILD_VERSION >= 0))
   currentLinks->SetDataSet(poly);
   currentLinks->BuildLinks();
 #else
@@ -296,7 +296,7 @@ int vtkvmtkSimplifyVoronoiDiagram::RequestData(
     // #pragma message "vtkvmtkSimplifyVoronoiDiagram::RequestData not functional. Must be updated based on Kitware/VTK@88efc809a"
     // vtkErrorMacro(<< "!");
     poly->SetPolys(currentPolys);
-#if (VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 0 && VTK_BUILD_VERSION >= 20221108)
+#if ((VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 0 && VTK_BUILD_VERSION >= 20221108) || (VTK_MAJOR_VERSION >= 9 && VTK_MINOR_VERSION >= 2 && VTK_BUILD_VERSION >= 0))
     currentLinks->SetDataSet(poly);
     currentLinks->BuildLinks();
 #else
diff --git a/vtkVmtk/Contrib/vtkvmtkCellDimensionFilter.cxx b/vtkVmtk/Contrib/vtkvmtkCellDimensionFilter.cxx
index 4e54cf3..2ea916e 100644
--- a/vtkVmtk/Contrib/vtkvmtkCellDimensionFilter.cxx
+++ b/vtkVmtk/Contrib/vtkvmtkCellDimensionFilter.cxx
@@ -59,17 +59,22 @@ int vtkvmtkCellDimensionFilter::FillInputPortInformation(int, vtkInformation *in
 
 void vtkvmtkCellDimensionFilter::ThresholdByLower(int lower)
 {
-  Threshold->ThresholdByLower(lower);
+  Threshold->SetLowerThreshold(lower);
+  Threshold->SetThresholdFunction(vtkThreshold::THRESHOLD_LOWER);
+  
 }
 
 void vtkvmtkCellDimensionFilter::ThresholdByUpper(int upper)
 {
-  Threshold->ThresholdByUpper(upper);
+  Threshold->SetUpperThreshold(upper);
+  Threshold->SetThresholdFunction(vtkThreshold::THRESHOLD_UPPER);
 }
 
 void vtkvmtkCellDimensionFilter::ThresholdBetween(int lower, int upper)
 {
-  Threshold->ThresholdBetween(lower,upper);
+  Threshold->SetLowerThreshold(lower);
+  Threshold->SetUpperThreshold(upper);
+  Threshold->SetThresholdFunction(vtkThreshold::THRESHOLD_BETWEEN);
 }
 
 int vtkvmtkCellDimensionFilter::GetLowerThreshold()
diff --git a/vtkVmtk/Segmentation/itkAnisotropicDiffusionVesselEnhancementImageFilter.txx b/vtkVmtk/Segmentation/itkAnisotropicDiffusionVesselEnhancementImageFilter.txx
index 47755ac..5617000 100644
--- a/vtkVmtk/Segmentation/itkAnisotropicDiffusionVesselEnhancementImageFilter.txx
+++ b/vtkVmtk/Segmentation/itkAnisotropicDiffusionVesselEnhancementImageFilter.txx
@@ -330,7 +330,11 @@ AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVes
   DenseFDThreadStruct str;
   str.Filter = this;
   str.TimeStep = dt;
+#if (ITK_VERSION_MAJOR >= 5)
+  this->GetMultiThreader()->SetNumberOfWorkUnits(this->GetNumberOfWorkUnits());
+#else
   this->GetMultiThreader()->SetNumberOfWorkUnits(this->GetNumberOfThreads());
+#endif
   this->GetMultiThreader()->SetSingleMethod(this->ApplyUpdateThreaderCallback,
                                             &str);
   // Multithread the execution
@@ -342,6 +346,14 @@ itk::ITK_THREAD_RETURN_TYPE
 AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVesselnessFilter>
 ::ApplyUpdateThreaderCallback( void * arg )
 {
+#if (ITK_VERSION_MAJOR >= 5)
+  using Info = PlatformMultiThreader::WorkUnitInfo;
+  const auto info = reinterpret_cast<const Info *>(arg);
+  const auto threadId = info->WorkUnitID;
+  const auto threadCount = info->NumberOfWorkUnits;
+  const auto str = reinterpret_cast<DenseFDThreadStruct *>(info->UserData);
+  int total;
+#else
   DenseFDThreadStruct * str;
   ThreadIdType threadId;
   int total, threadCount;
@@ -350,6 +362,8 @@ AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVes
   threadCount = ((PlatformMultiThreader::ThreadInfoStruct *)(arg))->NumberOfThreads;
 
   str = (DenseFDThreadStruct *)(((PlatformMultiThreader::ThreadInfoStruct *)(arg))->UserData);
+#endif
+
 
   // Execute the actual method with appropriate output region
   // first find out how many pieces extent can be split into.
@@ -389,14 +403,22 @@ AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVes
   str.Filter = this;
   str.TimeStep = NumericTraits<TimeStepType>::Zero;  // Not used during the
   // calculate change step.
+#if (ITK_VERSION_MAJOR >= 5)
+  this->GetMultiThreader()->SetNumberOfWorkUnits(this->GetNumberOfWorkUnits());
+#else
   this->GetMultiThreader()->SetNumberOfWorkUnits(this->GetNumberOfThreads());
+#endif
   this->GetMultiThreader()->SetSingleMethod(this->CalculateChangeThreaderCallback,
                                             &str);
 
   // Initialize the list of time step values that will be generated by the
   // various threads.  There is one distinct slot for each possible thread,
   // so this data structure is thread-safe.
+#if (ITK_VERSION_MAJOR >= 5)
+  threadCount = this->GetMultiThreader()->GetNumberOfWorkUnits();
+#else
   threadCount = this->GetMultiThreader()->GetNumberOfThreads();  
+#endif
   str.TimeStepList.resize(threadCount);
   str.ValidTimeStepList.resize(threadCount);
   for (int i =0; i < threadCount; ++i)
@@ -418,6 +440,14 @@ itk::ITK_THREAD_RETURN_TYPE
 AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVesselnessFilter>
 ::CalculateChangeThreaderCallback( void * arg )
 {
+#if (ITK_VERSION_MAJOR >= 5)
+  using Info = PlatformMultiThreader::WorkUnitInfo;
+  const auto info = reinterpret_cast<const Info *>(arg);
+  const auto threadId = info->WorkUnitID;
+  const auto threadCount = info->NumberOfWorkUnits;
+  const auto str = reinterpret_cast<DenseFDThreadStruct *>(info->UserData);
+  int total;
+#else
   DenseFDThreadStruct * str;
   ThreadIdType threadId;
   int total, threadCount;
@@ -426,6 +456,7 @@ AnisotropicDiffusionVesselEnhancementImageFilter<TInputImage, TOutputImage, TVes
   threadCount = ((PlatformMultiThreader::ThreadInfoStruct *)(arg))->NumberOfThreads;
 
   str = (DenseFDThreadStruct *)(((PlatformMultiThreader::ThreadInfoStruct *)(arg))->UserData);
+#endif
 
   // Execute the actual method with appropriate output region
   // first find out how many pieces extent can be split into.
diff --git a/vtkVmtk/Segmentation/itkFastMarchingDirectionalFreezeImageFilter.txx b/vtkVmtk/Segmentation/itkFastMarchingDirectionalFreezeImageFilter.txx
index 286a644..0687a36 100644
--- a/vtkVmtk/Segmentation/itkFastMarchingDirectionalFreezeImageFilter.txx
+++ b/vtkVmtk/Segmentation/itkFastMarchingDirectionalFreezeImageFilter.txx
@@ -194,7 +194,11 @@ FastMarchingDirectionalFreezeImageFilter<TLevelSet,TSpeedImage>
     if(! (neighIndex[j] > lastIndex[j] ||
           neighIndex[j] < startIndex[j]) )
       {
+#if (ITK_VERSION_MAJOR >= 5)
+      if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::LabelEnum::AlivePoint )
+#else
       if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::AlivePoint )
+#endif
         {
         dx_backward = centerPixel - output->GetPixel( neighIndex );
         }
@@ -206,7 +210,11 @@ FastMarchingDirectionalFreezeImageFilter<TLevelSet,TSpeedImage>
     if(! (neighIndex[j] > lastIndex[j] ||
           neighIndex[j] < startIndex[j]) )
       {
+#if (ITK_VERSION_MAJOR >= 5)
+      if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::LabelEnum::AlivePoint )
+#else
       if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::AlivePoint )
+#endif
         {
         dx_forward = output->GetPixel( neighIndex ) - centerPixel;
         }
diff --git a/vtkVmtk/Segmentation/itkFastMarchingUpwindGradientImageFilter.txx b/vtkVmtk/Segmentation/itkFastMarchingUpwindGradientImageFilter.txx
index 4d9acfa..001a49d 100644
--- a/vtkVmtk/Segmentation/itkFastMarchingUpwindGradientImageFilter.txx
+++ b/vtkVmtk/Segmentation/itkFastMarchingUpwindGradientImageFilter.txx
@@ -286,7 +286,11 @@ FastMarchingUpwindGradientImageFilter<TLevelSet,TSpeedImage>
     if(! (neighIndex[j] > lastIndex[j] || 
           neighIndex[j] < startIndex[j]) )
       {
+#if (ITK_VERSION_MAJOR >= 5)
+      if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::LabelEnum::AlivePoint )
+#else
       if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::AlivePoint )
+#endif
         {
         dx_backward = centerPixel - output->GetPixel( neighIndex );
         }
@@ -298,7 +302,11 @@ FastMarchingUpwindGradientImageFilter<TLevelSet,TSpeedImage>
     if(! (neighIndex[j] > lastIndex[j] || 
           neighIndex[j] < startIndex[j]) )
       {
+#if (ITK_VERSION_MAJOR >= 5)
+      if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::LabelEnum::AlivePoint )
+#else
       if ( this->GetLabelImage()->GetPixel( neighIndex ) == Superclass::AlivePoint )
+#endif
         {
         dx_forward = output->GetPixel( neighIndex ) - centerPixel;
         }
diff --git a/vtkVmtk/Segmentation/itkHessianSmoothed3DToVesselnessMeasureImageFilter.txx b/vtkVmtk/Segmentation/itkHessianSmoothed3DToVesselnessMeasureImageFilter.txx
index 63de6ed..befdd48 100644
--- a/vtkVmtk/Segmentation/itkHessianSmoothed3DToVesselnessMeasureImageFilter.txx
+++ b/vtkVmtk/Segmentation/itkHessianSmoothed3DToVesselnessMeasureImageFilter.txx
@@ -42,8 +42,13 @@ HessianSmoothed3DToVesselnessMeasureImageFilter< TPixel >
 
   m_SymmetricEigenValueFilter = EigenAnalysisFilterType::New();
   m_SymmetricEigenValueFilter->SetDimension( ImageDimension );
+#if (ITK_VERSION_MAJOR >=5)
+  m_SymmetricEigenValueFilter->OrderEigenValuesBy(
+      itk::SymmetricEigenAnalysisEnums::EigenValueOrder::OrderByValue );
+#else
   m_SymmetricEigenValueFilter->OrderEigenValuesBy( 
       EigenAnalysisFilterType::FunctorType::OrderByValue );
+#endif
 
   // By default, *do not* scale the vesselness measure by the largest
   // eigen value
diff --git a/vtkVmtk/Segmentation/vtkvmtkFastMarchingDirectionalFreezeImageFilter.cxx b/vtkVmtk/Segmentation/vtkvmtkFastMarchingDirectionalFreezeImageFilter.cxx
index 2cd0afa..c02a257 100644
--- a/vtkVmtk/Segmentation/vtkvmtkFastMarchingDirectionalFreezeImageFilter.cxx
+++ b/vtkVmtk/Segmentation/vtkvmtkFastMarchingDirectionalFreezeImageFilter.cxx
@@ -85,8 +85,12 @@ void vtkvmtkFastMarchingDirectionalFreezeImageFilter::SimpleExecute(vtkImageData
     {
     // TODO: here we get the point. We should get the cell center instead.
     ImageType::PointType seedPoint(input->GetPoint(this->Seeds->GetId(i)));
+#if (ITK_VERSION_MAJOR >= 5)
+    FastMarchingFilterType::NodeType::IndexType seedIndex = inImage->TransformPhysicalPointToIndex(seedPoint);
+#else
     FastMarchingFilterType::NodeType::IndexType seedIndex;
     inImage->TransformPhysicalPointToIndex(seedPoint,seedIndex);
+#endif
     FastMarchingFilterType::PixelType seedValue = itk::NumericTraits<FastMarchingFilterType::PixelType>::Zero;
     FastMarchingFilterType::NodeType seed;
     seed.SetValue(seedValue);
@@ -100,8 +104,12 @@ void vtkvmtkFastMarchingDirectionalFreezeImageFilter::SimpleExecute(vtkImageData
     {
     // TODO: here we get the point. We should get the cell center instead.
     ImageType::PointType seedPoint(input->GetPoint(this->Targets->GetId(i)));
+#if (ITK_VERSION_MAJOR >= 5)
+    FastMarchingFilterType::NodeType::IndexType seedIndex = inImage->TransformPhysicalPointToIndex(seedPoint);
+#else
     FastMarchingFilterType::NodeType::IndexType seedIndex;
     inImage->TransformPhysicalPointToIndex(seedPoint,seedIndex);
+#endif
     FastMarchingFilterType::PixelType seedValue = itk::NumericTraits<FastMarchingFilterType::PixelType>::Zero;
     FastMarchingFilterType::NodeType seed;
     seed.SetValue(seedValue);
diff --git a/vtkVmtk/Segmentation/vtkvmtkFastMarchingUpwindGradientImageFilter.cxx b/vtkVmtk/Segmentation/vtkvmtkFastMarchingUpwindGradientImageFilter.cxx
index 5fd8616..4a153e2 100644
--- a/vtkVmtk/Segmentation/vtkvmtkFastMarchingUpwindGradientImageFilter.cxx
+++ b/vtkVmtk/Segmentation/vtkvmtkFastMarchingUpwindGradientImageFilter.cxx
@@ -85,8 +85,12 @@ void vtkvmtkFastMarchingUpwindGradientImageFilter::SimpleExecute(vtkImageData* i
     {
     // TODO: here we get the point. We should get the cell center instead.
     ImageType::PointType seedPoint(input->GetPoint(this->Seeds->GetId(i)));
+#if (ITK_VERSION_MAJOR >= 5)
+    FastMarchingFilterType::NodeType::IndexType seedIndex = inImage->TransformPhysicalPointToIndex(seedPoint);
+#else
     FastMarchingFilterType::NodeType::IndexType seedIndex;
     inImage->TransformPhysicalPointToIndex(seedPoint,seedIndex);
+#endif
     FastMarchingFilterType::PixelType seedValue = itk::NumericTraits<FastMarchingFilterType::PixelType>::Zero;
     FastMarchingFilterType::NodeType seed;
     seed.SetValue(seedValue);
@@ -100,8 +104,12 @@ void vtkvmtkFastMarchingUpwindGradientImageFilter::SimpleExecute(vtkImageData* i
     {
     // TODO: here we get the point. We should get the cell center instead.
     ImageType::PointType seedPoint(input->GetPoint(this->Targets->GetId(i)));
+#if (ITK_VERSION_MAJOR >= 5)
+    FastMarchingFilterType::NodeType::IndexType seedIndex = inImage->TransformPhysicalPointToIndex(seedPoint);
+#else
     FastMarchingFilterType::NodeType::IndexType seedIndex;
     inImage->TransformPhysicalPointToIndex(seedPoint,seedIndex);
+#endif
     FastMarchingFilterType::PixelType seedValue = itk::NumericTraits<FastMarchingFilterType::PixelType>::Zero;
     FastMarchingFilterType::NodeType seed;
     seed.SetValue(seedValue);
diff --git a/vtkVmtk/Segmentation/vtkvmtkMedialCurveFilter.cxx b/vtkVmtk/Segmentation/vtkvmtkMedialCurveFilter.cxx
index 12d1fc1..ceabb4f 100755
--- a/vtkVmtk/Segmentation/vtkvmtkMedialCurveFilter.cxx
+++ b/vtkVmtk/Segmentation/vtkvmtkMedialCurveFilter.cxx
@@ -84,10 +84,15 @@ void vtkvmtkMedialCurveFilter::SimpleExecute(vtkImageData* input, vtkImageData*
 	gaussianFilterY->SetDirection(1);
 	gaussianFilterZ->SetDirection(2);
 
+#if (ITK_VERSION_MAJOR >= 5)
+	gaussianFilterX->SetOrder(itk::RecursiveGaussianImageFilterEnums::GaussianOrder::ZeroOrder);
+	gaussianFilterY->SetOrder(itk::RecursiveGaussianImageFilterEnums::GaussianOrder::ZeroOrder);
+	gaussianFilterZ->SetOrder(itk::RecursiveGaussianImageFilterEnums::GaussianOrder::ZeroOrder);
+#else
 	gaussianFilterX->SetOrder(RecursiveGaussianFilterType::ZeroOrder);
 	gaussianFilterY->SetOrder(RecursiveGaussianFilterType::ZeroOrder);
 	gaussianFilterZ->SetOrder(RecursiveGaussianFilterType::ZeroOrder);
-
+#endif
 	gaussianFilterX->SetNormalizeAcrossScale(false);
 	gaussianFilterY->SetNormalizeAcrossScale(false);
 	gaussianFilterZ->SetNormalizeAcrossScale(false);
@@ -123,4 +128,4 @@ void vtkvmtkMedialCurveFilter::SimpleExecute(vtkImageData* input, vtkImageData*
 	medialFilter->Update();
 
 	vtkvmtkITKFilterUtilities::ITKToVTKImage<UnsignedCharImageType>(medialFilter->GetOutput(),output);
-}
\ No newline at end of file
+}
diff --git a/vtkVmtk/Utilities/Doxygen/CMakeLists.txt b/vtkVmtk/Utilities/Doxygen/CMakeLists.txt
index 4202b21..564d178 100644
--- a/vtkVmtk/Utilities/Doxygen/CMakeLists.txt
+++ b/vtkVmtk/Utilities/Doxygen/CMakeLists.txt
@@ -1,7 +1,7 @@
 #
 # Build the documentation
 #
-include (${CMAKE_ROOT}/Modules/Documentation.cmake OPTIONAL)
+# Deprecated by CMake policy CMP0106: include (${CMAKE_ROOT}/Modules/Documentation.cmake OPTIONAL)
                                                                                                                
 if (BUILD_DOCUMENTATION)
                                                                                                                
diff --git a/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.cxx b/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.cxx
index 69225db..8e09895 100644
--- a/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.cxx
+++ b/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.cxx
@@ -626,43 +626,83 @@ int vtkvmtkITKArchetypeImageSeriesReader::RequestInformation(
         {
         scalarType = VTK_SHORT; // TODO - figure out why multi-file series doen't have an imageIO
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::UCHAR)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::UCHAR)
+#endif
         {
         scalarType = VTK_UNSIGNED_CHAR;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::CHAR)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::CHAR)
+#endif
         {
         scalarType = VTK_CHAR;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::USHORT)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::USHORT)
+#endif
         {
         scalarType = VTK_UNSIGNED_SHORT;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::SHORT)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::SHORT)
+#endif
         {
         scalarType = VTK_SHORT;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::UINT)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::UINT)
+#endif
         {
         scalarType = VTK_UNSIGNED_INT;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::INT)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::INT)
+#endif
         {
         scalarType = VTK_INT;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::ULONG)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::ULONG)
+#endif
         {
         scalarType = VTK_UNSIGNED_LONG;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::LONG)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::LONG)
+#endif
         {
         scalarType = VTK_LONG;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::FLOAT)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::FLOAT)
+#endif
         {
         scalarType = VTK_FLOAT;
         }
+#if (ITK_VERSION_MAJOR >= 5)
+      else if (imageIO->GetComponentType() == itk::IOComponentEnum::DOUBLE)
+#else
       else if (imageIO->GetComponentType() == itk::ImageIOBase::DOUBLE)
+#endif
         {
         scalarType = VTK_DOUBLE;
         }
@@ -676,54 +716,94 @@ int vtkvmtkITKArchetypeImageSeriesReader::RequestInformation(
         imageIO->SetFileName( this->FileNames[f] );
         imageIO->ReadImageInformation();
 
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::UCHAR )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::UCHAR )
+#endif
           {
           min = std::numeric_limits<uint8_t>::min() < min ? std::numeric_limits<uint8_t>::min() : min;
           max = std::numeric_limits<uint8_t>::max() > max ? std::numeric_limits<uint8_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::CHAR )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::CHAR )
+#endif
           {
           min = std::numeric_limits<int8_t>::min() < min ? std::numeric_limits<int8_t>::min() : min;
           max = std::numeric_limits<int8_t>::max() > max ? std::numeric_limits<int8_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::USHORT )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::USHORT )
+#endif
           {
           min = std::numeric_limits<uint16_t>::min() < min ? std::numeric_limits<uint16_t>::min() : min;
           max = std::numeric_limits<uint16_t>::max() > max ? std::numeric_limits<uint16_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::SHORT )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::SHORT )
+#endif
           {
           min = std::numeric_limits<int16_t>::min() < min ? std::numeric_limits<int16_t>::min() : min;
           max = std::numeric_limits<int16_t>::max() > max ? std::numeric_limits<int16_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::UINT )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::UINT )
+#endif
           {
           min = std::numeric_limits<uint32_t>::min() < min ? std::numeric_limits<uint32_t>::min() : min;
           max = std::numeric_limits<uint32_t>::max() > max ? std::numeric_limits<uint32_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::INT )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::INT )
+#endif
           {
           min = std::numeric_limits<int32_t>::min() < min ? std::numeric_limits<int32_t>::min() : min;
           max = std::numeric_limits<int32_t>::max() > max ? std::numeric_limits<int32_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::ULONG )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::ULONG )
+#endif
           { // note that on windows ULONG is only 32 bit
           min = std::numeric_limits<uint64_t>::min() < min ? std::numeric_limits<uint64_t>::min() : min;
           max = std::numeric_limits<uint64_t>::max() > max ? std::numeric_limits<uint64_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::LONG )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::LONG )
+#endif
           { // note that on windows LONG is only 32 bit
           min = std::numeric_limits<int64_t>::min() < min ? std::numeric_limits<int64_t>::min() : min;
           max = std::numeric_limits<int64_t>::max() > max ? std::numeric_limits<int64_t>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::FLOAT )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::FLOAT )
+#endif
           {
           // use -max() as min() for both float and double as temp workaround
           // should switch to lowest() function in C++ 11 in the future
           min = -std::numeric_limits<float>::max() < min ? -std::numeric_limits<float>::max() : min;
           max = std::numeric_limits<float>::max() > max ? std::numeric_limits<float>::max() : max;
           }
+#if (ITK_VERSION_MAJOR >= 5)
+        if ( imageIO->GetComponentType() == itk::IOComponentEnum::DOUBLE )
+#else
         if ( imageIO->GetComponentType() == itk::ImageIOBase::DOUBLE )
+#endif
           {
           min = -std::numeric_limits<double>::max() < min ? -std::numeric_limits<double>::max() : min;
           max = std::numeric_limits<double>::max() > max ? std::numeric_limits<double>::max() : max;
diff --git a/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.h b/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.h
index 36d35a3..49fddac 100644
--- a/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.h
+++ b/vtkVmtk/Utilities/vtkvmtkITK/vtkvmtkITKArchetypeImageSeriesReader.h
@@ -49,7 +49,11 @@ public:
   vtkTypeMacro(vtkvmtkITKArchetypeImageSeriesReader,vtkImageAlgorithm);
   void PrintSelf(std::ostream& os, vtkIndent indent) override;
 
+#if (ITK_VERSION_MAJOR >= 5)
+  typedef itk::SpatialOrientationEnums::ValidCoordinateOrientations CoordinateOrientationCode;
+#else
   typedef itk::SpatialOrientation::ValidCoordinateOrientationFlags CoordinateOrientationCode;
+#endif
 
   ///
   /// Specify the archetype filename for the series.
@@ -110,16 +114,26 @@ public:
   /// Set the orientation of the output image
   void SetDesiredCoordinateOrientationToAxial ()
     {
+#if (ITK_VERSION_MAJOR >= 5)
+    this->DesiredCoordinateOrientation =
+      itk::SpatialOrientationEnums::ValidCoordinateOrientations::ITK_COORDINATE_ORIENTATION_RAI;
+#else
     this->DesiredCoordinateOrientation =
       itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_RAI;
+#endif
     ///     itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_RPS;
     this->UseNativeCoordinateOrientation = 0;
     this->Modified();
     }
   void SetDesiredCoordinateOrientationToCoronal ()
     {
+#if (ITK_VERSION_MAJOR >= 5)
+    this->DesiredCoordinateOrientation =
+      itk::SpatialOrientationEnums::ValidCoordinateOrientations::ITK_COORDINATE_ORIENTATION_RSA;
+#else
     this->DesiredCoordinateOrientation =
       itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_RSA;
+#endif
     ///      itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_RIP;
     this->UseNativeCoordinateOrientation = 0;
     this->Modified();
@@ -127,7 +141,11 @@ public:
   void SetDesiredCoordinateOrientationToSagittal ()
   {
     this->DesiredCoordinateOrientation =
+#if (ITK_VERSION_MAJOR >= 5)
+      itk::SpatialOrientationEnums::ValidCoordinateOrientations::ITK_COORDINATE_ORIENTATION_ASL;
+#else
       itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_ASL;
+#endif
     ///      itk::SpatialOrientation::ITK_COORDINATE_ORIENTATION_AIR;
     this->UseNativeCoordinateOrientation = 0;
     this->Modified();
-- 
2.40.0.windows.1

